use json_schema_rs::generate_to_writer;

#[test]
fn string_fields_only() {
    let schema_json: &str = r#"{
        "type": "object",
        "title": "Foo",
        "required": ["id", "name"],
        "properties": {
            "name": { "type": "string" },
            "id": { "type": "string" }
        }
    }"#;

    let expected: &str = r"//! Generated by json-schema-rs. Do not edit manually.

use serde::{Deserialize, Serialize};

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct Foo {
    pub id: String,
    pub name: String,
}

";

    let mut output: Vec<u8> = Vec::new();
    generate_to_writer(schema_json, &mut output).expect("generate_to_writer should succeed");

    let actual: String = String::from_utf8(output).expect("output should be valid UTF-8");

    assert_eq!(expected, actual, "expected output to match exactly");
}

#[test]
fn nested_objects() {
    let schema_json: &str = r#"{
        "type": "object",
        "title": "Outer",
        "required": ["inner"],
        "properties": {
            "inner": {
                "type": "object",
                "title": "Inner",
                "required": ["value"],
                "properties": {
                    "value": { "type": "string" }
                }
            }
        }
    }"#;

    let expected: &str = r"//! Generated by json-schema-rs. Do not edit manually.

use serde::{Deserialize, Serialize};

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct Inner {
    pub value: String,
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct Outer {
    pub inner: Inner,
}

";

    let mut output: Vec<u8> = Vec::new();
    generate_to_writer(schema_json, &mut output).expect("generate_to_writer should succeed");

    let actual: String = String::from_utf8(output).expect("output should be valid UTF-8");

    assert_eq!(expected, actual, "expected output to match exactly");
}

#[test]
fn struct_names_with_spaces_in_title_are_sanitized() {
    let schema_json: &str = r#"{
        "title": "WidgetFile",
        "type": "object",
        "required": ["widget"],
        "properties": {
            "widget": {
                "title": "The Widget Schema",
                "type": "object",
                "required": ["owner", "name", "version"],
                "properties": {
                    "owner": { "type": "string" },
                    "name": { "type": "string" },
                    "version": { "type": "string" }
                }
            }
        }
    }"#;

    let expected: &str = r"//! Generated by json-schema-rs. Do not edit manually.

use serde::{Deserialize, Serialize};

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct TheWidgetSchema {
    pub name: String,
    pub owner: String,
    pub version: String,
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct WidgetFile {
    pub widget: TheWidgetSchema,
}

";

    let mut output: Vec<u8> = Vec::new();
    generate_to_writer(schema_json, &mut output).expect("generate_to_writer should succeed");

    let actual: String = String::from_utf8(output).expect("output should be valid UTF-8");

    assert_eq!(expected, actual, "expected output to match exactly");
}

#[test]
fn required_and_optional_fields() {
    let schema_json: &str = r#"{
        "type": "object",
        "title": "Mixed",
        "required": ["required_field"],
        "properties": {
            "required_field": { "type": "string" },
            "optional_field": { "type": "string" }
        }
    }"#;

    let expected: &str = r"//! Generated by json-schema-rs. Do not edit manually.

use serde::{Deserialize, Serialize};

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct Mixed {
    pub optional_field: Option<String>,
    pub required_field: String,
}

";

    let mut output: Vec<u8> = Vec::new();
    generate_to_writer(schema_json, &mut output).expect("generate_to_writer should succeed");

    let actual: String = String::from_utf8(output).expect("output should be valid UTF-8");

    assert_eq!(expected, actual, "expected output to match exactly");
}

#[test]
fn boolean_fields_required_and_optional() {
    let schema_json: &str = r#"{
        "type": "object",
        "title": "Flags",
        "required": ["enabled"],
        "properties": {
            "enabled": { "type": "boolean" },
            "name": { "type": "string" },
            "visible": { "type": "boolean" }
        }
    }"#;

    let expected: &str = r"//! Generated by json-schema-rs. Do not edit manually.

use serde::{Deserialize, Serialize};

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct Flags {
    pub enabled: bool,
    pub name: Option<String>,
    pub visible: Option<bool>,
}

";

    let mut output: Vec<u8> = Vec::new();
    generate_to_writer(schema_json, &mut output).expect("generate_to_writer should succeed");

    let actual: String = String::from_utf8(output).expect("output should be valid UTF-8");

    assert_eq!(expected, actual, "expected output to match exactly");
}

#[test]
fn integer_and_number_properties_required_and_optional() {
    let schema_json: &str = r#"{
        "type": "object",
        "title": "WithNumbers",
        "required": ["id"],
        "properties": {
            "id": { "type": "integer" },
            "count": { "type": "integer" },
            "score": { "type": "number" },
            "ratio": { "type": "number" }
        }
    }"#;

    let expected: &str = r"//! Generated by json-schema-rs. Do not edit manually.

use serde::{Deserialize, Serialize};

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct WithNumbers {
    pub count: Option<i64>,
    pub id: i64,
    pub ratio: Option<f64>,
    pub score: Option<f64>,
}

";

    let mut output: Vec<u8> = Vec::new();
    generate_to_writer(schema_json, &mut output).expect("generate_to_writer should succeed");

    let actual: String = String::from_utf8(output).expect("output should be valid UTF-8");

    assert_eq!(expected, actual, "expected output to match exactly");
}

#[test]
fn array_of_integers_and_array_of_numbers() {
    let schema_json: &str = r#"{
        "type": "object",
        "title": "WithNumberArrays",
        "required": ["ids"],
        "properties": {
            "ids": {
                "type": "array",
                "items": { "type": "integer" }
            },
            "weights": {
                "type": "array",
                "items": { "type": "number" }
            }
        }
    }"#;

    let expected: &str = r"//! Generated by json-schema-rs. Do not edit manually.

use serde::{Deserialize, Serialize};

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct WithNumberArrays {
    pub ids: Vec<i64>,
    pub weights: Option<Vec<f64>>,
}

";

    let mut output: Vec<u8> = Vec::new();
    generate_to_writer(schema_json, &mut output).expect("generate_to_writer should succeed");

    let actual: String = String::from_utf8(output).expect("output should be valid UTF-8");

    assert_eq!(expected, actual, "expected output to match exactly");
}

#[test]
fn generate_from_file_complex_schema() {
    let input_path: &str = "tests/schemas/complex-schema.json";
    let expected_path: &str = "tests/schemas/complex-schema-expected.rs";

    let schema_json: String = std::fs::read_to_string(input_path).expect("read schema file");
    let expected: String =
        std::fs::read_to_string(expected_path).expect("read expected output file");

    let mut output: Vec<u8> = Vec::new();
    generate_to_writer(&schema_json, &mut output).expect("generate_to_writer should succeed");

    let actual: String = String::from_utf8(output).expect("output should be valid UTF-8");

    assert_eq!(expected, actual, "expected output to match expected file");
}

#[test]
fn enum_field_generates_rust_enum() {
    let schema_json: &str = r#"{
        "type": "object",
        "title": "Doc",
        "properties": {
            "format": {
                "type": "string",
                "enum": ["plain", "markdown"]
            }
        }
    }"#;

    let expected: &str = r#"//! Generated by json-schema-rs. Do not edit manually.

use serde::{Deserialize, Serialize};

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub enum Format {
    #[serde(rename = "markdown")]
    Markdown,
    #[serde(rename = "plain")]
    Plain,
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct Doc {
    pub format: Option<Format>,
}

"#;

    let mut output: Vec<u8> = Vec::new();
    generate_to_writer(schema_json, &mut output).expect("generate_to_writer should succeed");

    let actual: String = String::from_utf8(output).expect("output should be valid UTF-8");

    assert_eq!(expected, actual, "expected output to match exactly");
}

#[test]
fn json_schema_duplicate_enum_values_deduplicate() {
    let schema_json: &str = r#"{
        "type": "object",
        "title": "Dedup",
        "properties": {
            "x": {
                "type": "string",
                "enum": ["a", "a"]
            }
        }
    }"#;

    let expected: &str = r#"//! Generated by json-schema-rs. Do not edit manually.

use serde::{Deserialize, Serialize};

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub enum X {
    #[serde(rename = "a")]
    A,
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct Dedup {
    pub x: Option<X>,
}

"#;

    let mut output: Vec<u8> = Vec::new();
    generate_to_writer(schema_json, &mut output).expect("generate_to_writer should succeed");

    let actual: String = String::from_utf8(output).expect("output should be valid UTF-8");

    assert_eq!(expected, actual, "expected output to match exactly");
}

#[test]
fn rust_output_collision_case_sensitive_variants() {
    let schema_json: &str = r#"{
        "type": "object",
        "title": "StateDoc",
        "properties": {
            "state": {
                "type": "string",
                "enum": ["PENDING", "pending", "Pending"]
            }
        }
    }"#;

    let expected: &str = r#"//! Generated by json-schema-rs. Do not edit manually.

use serde::{Deserialize, Serialize};

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub enum State {
    #[serde(rename = "PENDING")]
    Pending_0,
    #[serde(rename = "Pending")]
    Pending_1,
    #[serde(rename = "pending")]
    Pending_2,
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct StateDoc {
    pub state: Option<State>,
}

"#;

    let mut output: Vec<u8> = Vec::new();
    generate_to_writer(schema_json, &mut output).expect("generate_to_writer should succeed");

    let actual: String = String::from_utf8(output).expect("output should be valid UTF-8");

    assert_eq!(expected, actual, "expected output to match exactly");
}

#[test]
fn enum_determinism_same_output_regardless_of_input_order() {
    let schema_json_a: &str = r#"{
        "type": "object",
        "title": "Doc",
        "properties": {
            "format": {
                "type": "string",
                "enum": ["markdown", "plain"]
            }
        }
    }"#;

    let schema_json_b: &str = r#"{
        "type": "object",
        "title": "Doc",
        "properties": {
            "format": {
                "type": "string",
                "enum": ["plain", "markdown"]
            }
        }
    }"#;

    let mut output_a: Vec<u8> = Vec::new();
    generate_to_writer(schema_json_a, &mut output_a).expect("generate_to_writer should succeed");
    let actual_a: String = String::from_utf8(output_a).expect("output should be valid UTF-8");

    let mut output_b: Vec<u8> = Vec::new();
    generate_to_writer(schema_json_b, &mut output_b).expect("generate_to_writer should succeed");
    let actual_b: String = String::from_utf8(output_b).expect("output should be valid UTF-8");

    assert_eq!(actual_a, actual_b, "enum order should not affect output");
}

#[test]
fn array_of_strings_required_and_optional() {
    let schema_json: &str = r#"{
        "type": "object",
        "title": "WithArrays",
        "required": ["tags"],
        "properties": {
            "tags": {
                "type": "array",
                "items": { "type": "string" }
            },
            "labels": {
                "type": "array",
                "items": { "type": "string" }
            }
        }
    }"#;

    let expected: &str = r"//! Generated by json-schema-rs. Do not edit manually.

use serde::{Deserialize, Serialize};

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct WithArrays {
    pub labels: Option<Vec<String>>,
    pub tags: Vec<String>,
}

";

    let mut output: Vec<u8> = Vec::new();
    generate_to_writer(schema_json, &mut output).expect("generate_to_writer should succeed");

    let actual: String = String::from_utf8(output).expect("output should be valid UTF-8");

    assert_eq!(expected, actual, "expected output to match exactly");
}

#[test]
fn array_of_objects_nested_struct_emission_order() {
    let schema_json: &str = r#"{
        "type": "object",
        "title": "DocWithItems",
        "required": ["items"],
        "properties": {
            "items": {
                "type": "array",
                "items": {
                    "type": "object",
                    "title": "Item",
                    "required": ["id"],
                    "properties": {
                        "id": { "type": "string" },
                        "name": { "type": "string" }
                    }
                }
            }
        }
    }"#;

    let expected: &str = r"//! Generated by json-schema-rs. Do not edit manually.

use serde::{Deserialize, Serialize};

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct Item {
    pub id: String,
    pub name: Option<String>,
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct DocWithItems {
    pub items: Vec<Item>,
}

";

    let mut output: Vec<u8> = Vec::new();
    generate_to_writer(schema_json, &mut output).expect("generate_to_writer should succeed");

    let actual: String = String::from_utf8(output).expect("output should be valid UTF-8");

    assert_eq!(expected, actual, "expected output to match exactly");
}

#[test]
fn array_of_enums() {
    let schema_json: &str = r#"{
        "type": "object",
        "title": "DocWithStatuses",
        "properties": {
            "statuses": {
                "type": "array",
                "items": {
                    "type": "string",
                    "enum": ["active", "inactive"]
                }
            }
        }
    }"#;

    let expected: &str = r#"//! Generated by json-schema-rs. Do not edit manually.

use serde::{Deserialize, Serialize};

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub enum Statuses {
    #[serde(rename = "active")]
    Active,
    #[serde(rename = "inactive")]
    Inactive,
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct DocWithStatuses {
    pub statuses: Option<Vec<Statuses>>,
}

"#;

    let mut output: Vec<u8> = Vec::new();
    generate_to_writer(schema_json, &mut output).expect("generate_to_writer should succeed");

    let actual: String = String::from_utf8(output).expect("output should be valid UTF-8");

    assert_eq!(expected, actual, "expected output to match exactly");
}

#[test]
fn additional_properties_false_denies_unknown_fields() {
    let schema_json: &str = r#"{
        "type": "object",
        "title": "Strict",
        "additionalProperties": false,
        "properties": {
            "name": { "type": "string" }
        }
    }"#;

    let expected: &str = r"//! Generated by json-schema-rs. Do not edit manually.

use serde::{Deserialize, Serialize};

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
#[serde(deny_unknown_fields)]
pub struct Strict {
    pub name: Option<String>,
}

";

    let mut output: Vec<u8> = Vec::new();
    generate_to_writer(schema_json, &mut output).expect("generate_to_writer should succeed");

    let actual: String = String::from_utf8(output).expect("output should be valid UTF-8");

    assert_eq!(expected, actual, "expected output to match exactly");
}

#[test]
fn additional_properties_typed_string_generates_btreemap() {
    let schema_json: &str = r#"{
        "type": "object",
        "title": "WithExtras",
        "additionalProperties": { "type": "string" },
        "properties": {
            "id": { "type": "string" }
        }
    }"#;

    let expected: &str = r"//! Generated by json-schema-rs. Do not edit manually.

use serde::{Deserialize, Serialize};
use std::collections::BTreeMap;

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct WithExtras {
    #[serde(flatten)]
    pub additional_properties: BTreeMap<String, String>,
    pub id: Option<String>,
}

";

    let mut output: Vec<u8> = Vec::new();
    generate_to_writer(schema_json, &mut output).expect("generate_to_writer should succeed");

    let actual: String = String::from_utf8(output).expect("output should be valid UTF-8");

    assert_eq!(expected, actual, "expected output to match exactly");
}

#[test]
fn additional_properties_typed_integer_generates_btreemap() {
    let schema_json: &str = r#"{
        "type": "object",
        "title": "Counts",
        "additionalProperties": { "type": "integer" },
        "properties": {
            "total": { "type": "integer" }
        }
    }"#;

    let expected: &str = r"//! Generated by json-schema-rs. Do not edit manually.

use serde::{Deserialize, Serialize};
use std::collections::BTreeMap;

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct Counts {
    #[serde(flatten)]
    pub additional_properties: BTreeMap<String, i64>,
    pub total: Option<i64>,
}

";

    let mut output: Vec<u8> = Vec::new();
    generate_to_writer(schema_json, &mut output).expect("generate_to_writer should succeed");

    let actual: String = String::from_utf8(output).expect("output should be valid UTF-8");

    assert_eq!(expected, actual, "expected output to match exactly");
}

#[test]
fn additional_properties_untyped_generates_json_value() {
    let schema_json: &str = r#"{
        "type": "object",
        "title": "Flexible",
        "additionalProperties": {},
        "properties": {
            "tag": { "type": "string" }
        }
    }"#;

    let expected: &str = r"//! Generated by json-schema-rs. Do not edit manually.

use serde::{Deserialize, Serialize};
use std::collections::BTreeMap;

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct Flexible {
    #[serde(flatten)]
    pub additional_properties: BTreeMap<String, serde_json::Value>,
    pub tag: Option<String>,
}

";

    let mut output: Vec<u8> = Vec::new();
    generate_to_writer(schema_json, &mut output).expect("generate_to_writer should succeed");

    let actual: String = String::from_utf8(output).expect("output should be valid UTF-8");

    assert_eq!(expected, actual, "expected output to match exactly");
}

#[test]
fn additional_properties_nested_object() {
    let schema_json: &str = r#"{
        "type": "object",
        "title": "Doc",
        "additionalProperties": {
            "type": "object",
            "properties": {
                "value": { "type": "string" }
            }
        },
        "properties": {
            "id": { "type": "string" }
        }
    }"#;

    let expected: &str = r"//! Generated by json-schema-rs. Do not edit manually.

use serde::{Deserialize, Serialize};
use std::collections::BTreeMap;

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct DocExtra {
    pub value: Option<String>,
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct Doc {
    #[serde(flatten)]
    pub additional_properties: BTreeMap<String, DocExtra>,
    pub id: Option<String>,
}

";

    let mut output: Vec<u8> = Vec::new();
    generate_to_writer(schema_json, &mut output).expect("generate_to_writer should succeed");

    let actual: String = String::from_utf8(output).expect("output should be valid UTF-8");

    assert_eq!(expected, actual, "expected output to match exactly");
}
