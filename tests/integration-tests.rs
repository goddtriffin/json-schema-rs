use json_schema_rs::generate_to_writer;

#[test]
fn string_fields_only() {
    let schema_json: &str = r#"{
        "type": "object",
        "title": "Foo",
        "required": ["id", "name"],
        "properties": {
            "name": { "type": "string" },
            "id": { "type": "string" }
        }
    }"#;

    let expected: &str = r"//! Generated by json-schema-rs. Do not edit manually.

use serde::{Deserialize, Serialize};

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct Foo {
    pub id: String,
    pub name: String,
}

";

    let mut output: Vec<u8> = Vec::new();
    generate_to_writer(schema_json, &mut output).expect("generate_to_writer should succeed");

    let actual: String = String::from_utf8(output).expect("output should be valid UTF-8");

    assert_eq!(expected, actual, "expected output to match exactly");
}

#[test]
fn nested_objects() {
    let schema_json: &str = r#"{
        "type": "object",
        "title": "Outer",
        "required": ["inner"],
        "properties": {
            "inner": {
                "type": "object",
                "title": "Inner",
                "required": ["value"],
                "properties": {
                    "value": { "type": "string" }
                }
            }
        }
    }"#;

    let expected: &str = r"//! Generated by json-schema-rs. Do not edit manually.

use serde::{Deserialize, Serialize};

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct Inner {
    pub value: String,
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct Outer {
    pub inner: Inner,
}

";

    let mut output: Vec<u8> = Vec::new();
    generate_to_writer(schema_json, &mut output).expect("generate_to_writer should succeed");

    let actual: String = String::from_utf8(output).expect("output should be valid UTF-8");

    assert_eq!(expected, actual, "expected output to match exactly");
}

#[test]
fn struct_names_with_spaces_in_title_are_sanitized() {
    let schema_json: &str = r#"{
        "title": "WidgetFile",
        "type": "object",
        "required": ["widget"],
        "properties": {
            "widget": {
                "title": "The Widget Schema",
                "type": "object",
                "required": ["owner", "name", "version"],
                "properties": {
                    "owner": { "type": "string" },
                    "name": { "type": "string" },
                    "version": { "type": "string" }
                }
            }
        }
    }"#;

    let expected: &str = r"//! Generated by json-schema-rs. Do not edit manually.

use serde::{Deserialize, Serialize};

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct TheWidgetSchema {
    pub name: String,
    pub owner: String,
    pub version: String,
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct WidgetFile {
    pub widget: TheWidgetSchema,
}

";

    let mut output: Vec<u8> = Vec::new();
    generate_to_writer(schema_json, &mut output).expect("generate_to_writer should succeed");

    let actual: String = String::from_utf8(output).expect("output should be valid UTF-8");

    assert_eq!(expected, actual, "expected output to match exactly");
}

#[test]
fn required_and_optional_fields() {
    let schema_json: &str = r#"{
        "type": "object",
        "title": "Mixed",
        "required": ["required_field"],
        "properties": {
            "required_field": { "type": "string" },
            "optional_field": { "type": "string" }
        }
    }"#;

    let expected: &str = r"//! Generated by json-schema-rs. Do not edit manually.

use serde::{Deserialize, Serialize};

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct Mixed {
    pub optional_field: Option<String>,
    pub required_field: String,
}

";

    let mut output: Vec<u8> = Vec::new();
    generate_to_writer(schema_json, &mut output).expect("generate_to_writer should succeed");

    let actual: String = String::from_utf8(output).expect("output should be valid UTF-8");

    assert_eq!(expected, actual, "expected output to match exactly");
}

#[test]
fn generate_from_file_complex_schema() {
    let input_path: &str = "tests/schemas/complex-schema.json";
    let expected_path: &str = "tests/schemas/complex-schema-expected.rs";

    let schema_json: String = std::fs::read_to_string(input_path).expect("read schema file");
    let expected: String =
        std::fs::read_to_string(expected_path).expect("read expected output file");

    let mut output: Vec<u8> = Vec::new();
    generate_to_writer(&schema_json, &mut output).expect("generate_to_writer should succeed");

    let actual: String = String::from_utf8(output).expect("output should be valid UTF-8");

    assert_eq!(expected, actual, "expected output to match expected file");
}

#[test]
fn enum_field_generates_rust_enum() {
    let schema_json: &str = r#"{
        "type": "object",
        "title": "Doc",
        "properties": {
            "format": {
                "type": "string",
                "enum": ["plain", "markdown"]
            }
        }
    }"#;

    let expected: &str = r#"//! Generated by json-schema-rs. Do not edit manually.

use serde::{Deserialize, Serialize};

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub enum Format {
    #[serde(rename = "markdown")]
    Markdown,
    #[serde(rename = "plain")]
    Plain,
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct Doc {
    pub format: Option<Format>,
}

"#;

    let mut output: Vec<u8> = Vec::new();
    generate_to_writer(schema_json, &mut output).expect("generate_to_writer should succeed");

    let actual: String = String::from_utf8(output).expect("output should be valid UTF-8");

    assert_eq!(expected, actual, "expected output to match exactly");
}

#[test]
fn json_schema_duplicate_enum_values_deduplicate() {
    let schema_json: &str = r#"{
        "type": "object",
        "title": "Dedup",
        "properties": {
            "x": {
                "type": "string",
                "enum": ["a", "a"]
            }
        }
    }"#;

    let expected: &str = r#"//! Generated by json-schema-rs. Do not edit manually.

use serde::{Deserialize, Serialize};

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub enum X {
    #[serde(rename = "a")]
    A,
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct Dedup {
    pub x: Option<X>,
}

"#;

    let mut output: Vec<u8> = Vec::new();
    generate_to_writer(schema_json, &mut output).expect("generate_to_writer should succeed");

    let actual: String = String::from_utf8(output).expect("output should be valid UTF-8");

    assert_eq!(expected, actual, "expected output to match exactly");
}

#[test]
fn rust_output_collision_case_sensitive_variants() {
    let schema_json: &str = r#"{
        "type": "object",
        "title": "StateDoc",
        "properties": {
            "state": {
                "type": "string",
                "enum": ["PENDING", "pending", "Pending"]
            }
        }
    }"#;

    let expected: &str = r#"//! Generated by json-schema-rs. Do not edit manually.

use serde::{Deserialize, Serialize};

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub enum State {
    #[serde(rename = "PENDING")]
    Pending_0,
    #[serde(rename = "Pending")]
    Pending_1,
    #[serde(rename = "pending")]
    Pending_2,
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct StateDoc {
    pub state: Option<State>,
}

"#;

    let mut output: Vec<u8> = Vec::new();
    generate_to_writer(schema_json, &mut output).expect("generate_to_writer should succeed");

    let actual: String = String::from_utf8(output).expect("output should be valid UTF-8");

    assert_eq!(expected, actual, "expected output to match exactly");
}

#[test]
fn enum_determinism_same_output_regardless_of_input_order() {
    let schema_json_a: &str = r#"{
        "type": "object",
        "title": "Doc",
        "properties": {
            "format": {
                "type": "string",
                "enum": ["markdown", "plain"]
            }
        }
    }"#;

    let schema_json_b: &str = r#"{
        "type": "object",
        "title": "Doc",
        "properties": {
            "format": {
                "type": "string",
                "enum": ["plain", "markdown"]
            }
        }
    }"#;

    let mut output_a: Vec<u8> = Vec::new();
    generate_to_writer(schema_json_a, &mut output_a).expect("generate_to_writer should succeed");
    let actual_a: String = String::from_utf8(output_a).expect("output should be valid UTF-8");

    let mut output_b: Vec<u8> = Vec::new();
    generate_to_writer(schema_json_b, &mut output_b).expect("generate_to_writer should succeed");
    let actual_b: String = String::from_utf8(output_b).expect("output should be valid UTF-8");

    assert_eq!(actual_a, actual_b, "enum order should not affect output");
}
