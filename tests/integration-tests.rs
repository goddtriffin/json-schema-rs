use json_schema_rs::{
    GenerateSettings, JsonSchemaGenError, SchemaValidationError, SchemaValidationIssue,
    SchemaValidationIssueKind, generate_to_writer,
};

#[test]
fn string_fields_only() {
    let schema_json: &str = r#"{
        "type": "object",
        "title": "Foo",
        "required": ["id", "name"],
        "properties": {
            "name": { "type": "string" },
            "id": { "type": "string" }
        }
    }"#;

    let expected: &str = r"//! Generated by json-schema-rs. Do not edit manually.

use serde::{Deserialize, Serialize};

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct Foo {
    pub id: String,
    pub name: String,
}

";

    let mut output: Vec<u8> = Vec::new();
    generate_to_writer(schema_json, &mut output, &GenerateSettings::default())
        .expect("generate_to_writer should succeed");

    let actual: String = String::from_utf8(output).expect("output should be valid UTF-8");

    assert_eq!(expected, actual, "expected output to match exactly");
}

#[test]
fn nested_objects() {
    let schema_json: &str = r#"{
        "type": "object",
        "title": "Outer",
        "required": ["inner"],
        "properties": {
            "inner": {
                "type": "object",
                "title": "Inner",
                "required": ["value"],
                "properties": {
                    "value": { "type": "string" }
                }
            }
        }
    }"#;

    let expected: &str = r"//! Generated by json-schema-rs. Do not edit manually.

use serde::{Deserialize, Serialize};

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct Inner {
    pub value: String,
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct Outer {
    pub inner: Inner,
}

";

    let mut output: Vec<u8> = Vec::new();
    generate_to_writer(schema_json, &mut output, &GenerateSettings::default())
        .expect("generate_to_writer should succeed");

    let actual: String = String::from_utf8(output).expect("output should be valid UTF-8");

    assert_eq!(expected, actual, "expected output to match exactly");
}

#[test]
fn struct_names_with_spaces_in_title_are_sanitized() {
    let schema_json: &str = r#"{
        "title": "WidgetFile",
        "type": "object",
        "required": ["widget"],
        "properties": {
            "widget": {
                "title": "The Widget Schema",
                "type": "object",
                "required": ["owner", "name", "version"],
                "properties": {
                    "owner": { "type": "string" },
                    "name": { "type": "string" },
                    "version": { "type": "string" }
                }
            }
        }
    }"#;

    let expected: &str = r"//! Generated by json-schema-rs. Do not edit manually.

use serde::{Deserialize, Serialize};

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct TheWidgetSchema {
    pub name: String,
    pub owner: String,
    pub version: String,
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct WidgetFile {
    pub widget: TheWidgetSchema,
}

";

    let mut output: Vec<u8> = Vec::new();
    generate_to_writer(schema_json, &mut output, &GenerateSettings::default())
        .expect("generate_to_writer should succeed");

    let actual: String = String::from_utf8(output).expect("output should be valid UTF-8");

    assert_eq!(expected, actual, "expected output to match exactly");
}

#[test]
fn required_and_optional_fields() {
    let schema_json: &str = r#"{
        "type": "object",
        "title": "Mixed",
        "required": ["required_field"],
        "properties": {
            "required_field": { "type": "string" },
            "optional_field": { "type": "string" }
        }
    }"#;

    let expected: &str = r"//! Generated by json-schema-rs. Do not edit manually.

use serde::{Deserialize, Serialize};

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct Mixed {
    pub optional_field: Option<String>,
    pub required_field: String,
}

";

    let mut output: Vec<u8> = Vec::new();
    generate_to_writer(schema_json, &mut output, &GenerateSettings::default())
        .expect("generate_to_writer should succeed");

    let actual: String = String::from_utf8(output).expect("output should be valid UTF-8");

    assert_eq!(expected, actual, "expected output to match exactly");
}

#[test]
fn boolean_fields_required_and_optional() {
    let schema_json: &str = r#"{
        "type": "object",
        "title": "Flags",
        "required": ["enabled"],
        "properties": {
            "enabled": { "type": "boolean" },
            "name": { "type": "string" },
            "visible": { "type": "boolean" }
        }
    }"#;

    let expected: &str = r"//! Generated by json-schema-rs. Do not edit manually.

use serde::{Deserialize, Serialize};

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct Flags {
    pub enabled: bool,
    pub name: Option<String>,
    pub visible: Option<bool>,
}

";

    let mut output: Vec<u8> = Vec::new();
    generate_to_writer(schema_json, &mut output, &GenerateSettings::default())
        .expect("generate_to_writer should succeed");

    let actual: String = String::from_utf8(output).expect("output should be valid UTF-8");

    assert_eq!(expected, actual, "expected output to match exactly");
}

#[test]
fn integer_and_number_properties_required_and_optional() {
    let schema_json: &str = r#"{
        "type": "object",
        "title": "WithNumbers",
        "required": ["id"],
        "properties": {
            "id": { "type": "integer" },
            "count": { "type": "integer" },
            "score": { "type": "number" },
            "ratio": { "type": "number" }
        }
    }"#;

    let expected: &str = r"//! Generated by json-schema-rs. Do not edit manually.

use serde::{Deserialize, Serialize};

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct WithNumbers {
    pub count: Option<i64>,
    pub id: i64,
    pub ratio: Option<f64>,
    pub score: Option<f64>,
}

";

    let mut output: Vec<u8> = Vec::new();
    generate_to_writer(schema_json, &mut output, &GenerateSettings::default())
        .expect("generate_to_writer should succeed");

    let actual: String = String::from_utf8(output).expect("output should be valid UTF-8");

    assert_eq!(expected, actual, "expected output to match exactly");
}

#[test]
fn minimum_maximum_select_smaller_integer_and_float_types() {
    let schema_json: &str = r#"{
        "type": "object",
        "title": "WithBounds",
        "properties": {
            "byte": { "type": "integer", "minimum": 0, "maximum": 255 },
            "signed_byte": { "type": "integer", "minimum": -128, "maximum": 127 },
            "unbounded_int": { "type": "integer" },
            "ratio": { "type": "number", "minimum": 0, "maximum": 1 },
            "unbounded_float": { "type": "number" }
        }
    }"#;

    let expected: &str = r"//! Generated by json-schema-rs. Do not edit manually.

use serde::{Deserialize, Serialize};

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct WithBounds {
    pub byte: Option<u8>,
    pub ratio: Option<f32>,
    pub signed_byte: Option<i8>,
    pub unbounded_float: Option<f64>,
    pub unbounded_int: Option<i64>,
}

";

    let mut output: Vec<u8> = Vec::new();
    generate_to_writer(schema_json, &mut output, &GenerateSettings::default())
        .expect("generate_to_writer should succeed");

    let actual: String = String::from_utf8(output).expect("output should be valid UTF-8");

    assert_eq!(expected, actual, "expected output to match exactly");
}

#[test]
fn array_of_integers_and_array_of_numbers() {
    let schema_json: &str = r#"{
        "type": "object",
        "title": "WithNumberArrays",
        "required": ["ids"],
        "properties": {
            "ids": {
                "type": "array",
                "items": { "type": "integer" }
            },
            "weights": {
                "type": "array",
                "items": { "type": "number" }
            }
        }
    }"#;

    let expected: &str = r"//! Generated by json-schema-rs. Do not edit manually.

use serde::{Deserialize, Serialize};

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct WithNumberArrays {
    pub ids: Vec<i64>,
    pub weights: Option<Vec<f64>>,
}

";

    let mut output: Vec<u8> = Vec::new();
    generate_to_writer(schema_json, &mut output, &GenerateSettings::default())
        .expect("generate_to_writer should succeed");

    let actual: String = String::from_utf8(output).expect("output should be valid UTF-8");

    assert_eq!(expected, actual, "expected output to match exactly");
}

#[test]
fn generate_from_file_complex_schema() {
    let input_path: &str = "tests/schemas/complex-schema.json";
    let expected_path: &str = "tests/schemas/complex-schema-expected.rs";

    let schema_json: String = std::fs::read_to_string(input_path).expect("read schema file");
    let expected: String =
        std::fs::read_to_string(expected_path).expect("read expected output file");

    let mut output: Vec<u8> = Vec::new();
    generate_to_writer(&schema_json, &mut output, &GenerateSettings::default())
        .expect("generate_to_writer should succeed");

    let actual: String = String::from_utf8(output).expect("output should be valid UTF-8");

    assert_eq!(expected, actual, "expected output to match expected file");
}

#[test]
fn description_emits_doc_comments() {
    let schema_json: &str = r#"{
        "type": "object",
        "title": "Root",
        "description": "Root struct doc",
        "required": ["id"],
        "properties": {
            "id": { "type": "string", "description": "A required string" },
            "status": {
                "type": "string",
                "enum": ["active", "inactive"],
                "description": "Status enum"
            }
        }
    }"#;

    let expected: &str = r#"//! Generated by json-schema-rs. Do not edit manually.

use serde::{Deserialize, Serialize};

/// Status enum
#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub enum Status {
    #[serde(rename = "active")]
    Active,
    #[serde(rename = "inactive")]
    Inactive,
}

/// Root struct doc
#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct Root {
    /// A required string
    pub id: String,
    /// Status enum
    pub status: Option<Status>,
}

"#;

    let mut output: Vec<u8> = Vec::new();
    generate_to_writer(schema_json, &mut output, &GenerateSettings::default())
        .expect("generate_to_writer should succeed");

    let actual: String = String::from_utf8(output).expect("output should be valid UTF-8");

    assert_eq!(expected, actual, "expected output to match exactly");
}

#[test]
fn enum_field_generates_rust_enum() {
    let schema_json: &str = r#"{
        "type": "object",
        "title": "Doc",
        "properties": {
            "format": {
                "type": "string",
                "enum": ["plain", "markdown"]
            }
        }
    }"#;

    let expected: &str = r#"//! Generated by json-schema-rs. Do not edit manually.

use serde::{Deserialize, Serialize};

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub enum Format {
    #[serde(rename = "markdown")]
    Markdown,
    #[serde(rename = "plain")]
    Plain,
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct Doc {
    pub format: Option<Format>,
}

"#;

    let mut output: Vec<u8> = Vec::new();
    generate_to_writer(schema_json, &mut output, &GenerateSettings::default())
        .expect("generate_to_writer should succeed");

    let actual: String = String::from_utf8(output).expect("output should be valid UTF-8");

    assert_eq!(expected, actual, "expected output to match exactly");
}

#[test]
fn json_schema_duplicate_enum_values_deduplicate() {
    let schema_json: &str = r#"{
        "type": "object",
        "title": "Dedup",
        "properties": {
            "x": {
                "type": "string",
                "enum": ["a", "a"]
            }
        }
    }"#;

    let expected: &str = r#"//! Generated by json-schema-rs. Do not edit manually.

use serde::{Deserialize, Serialize};

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub enum X {
    #[serde(rename = "a")]
    A,
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct Dedup {
    pub x: Option<X>,
}

"#;

    let mut output: Vec<u8> = Vec::new();
    generate_to_writer(schema_json, &mut output, &GenerateSettings::default())
        .expect("generate_to_writer should succeed");

    let actual: String = String::from_utf8(output).expect("output should be valid UTF-8");

    assert_eq!(expected, actual, "expected output to match exactly");
}

#[test]
fn rust_output_collision_case_sensitive_variants() {
    let schema_json: &str = r#"{
        "type": "object",
        "title": "StateDoc",
        "properties": {
            "state": {
                "type": "string",
                "enum": ["PENDING", "pending", "Pending"]
            }
        }
    }"#;

    let expected: &str = r#"//! Generated by json-schema-rs. Do not edit manually.

use serde::{Deserialize, Serialize};

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub enum State {
    #[serde(rename = "PENDING")]
    Pending_0,
    #[serde(rename = "Pending")]
    Pending_1,
    #[serde(rename = "pending")]
    Pending_2,
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct StateDoc {
    pub state: Option<State>,
}

"#;

    let mut output: Vec<u8> = Vec::new();
    generate_to_writer(schema_json, &mut output, &GenerateSettings::default())
        .expect("generate_to_writer should succeed");

    let actual: String = String::from_utf8(output).expect("output should be valid UTF-8");

    assert_eq!(expected, actual, "expected output to match exactly");
}

#[test]
fn enum_determinism_same_output_regardless_of_input_order() {
    let schema_json_a: &str = r#"{
        "type": "object",
        "title": "Doc",
        "properties": {
            "format": {
                "type": "string",
                "enum": ["markdown", "plain"]
            }
        }
    }"#;

    let schema_json_b: &str = r#"{
        "type": "object",
        "title": "Doc",
        "properties": {
            "format": {
                "type": "string",
                "enum": ["plain", "markdown"]
            }
        }
    }"#;

    let mut output_a: Vec<u8> = Vec::new();
    generate_to_writer(schema_json_a, &mut output_a, &GenerateSettings::default())
        .expect("generate_to_writer should succeed");
    let actual_a: String = String::from_utf8(output_a).expect("output should be valid UTF-8");

    let mut output_b: Vec<u8> = Vec::new();
    generate_to_writer(schema_json_b, &mut output_b, &GenerateSettings::default())
        .expect("generate_to_writer should succeed");
    let actual_b: String = String::from_utf8(output_b).expect("output should be valid UTF-8");

    assert_eq!(actual_a, actual_b, "enum order should not affect output");
}

#[test]
fn array_of_strings_required_and_optional() {
    let schema_json: &str = r#"{
        "type": "object",
        "title": "WithArrays",
        "required": ["tags"],
        "properties": {
            "tags": {
                "type": "array",
                "items": { "type": "string" }
            },
            "labels": {
                "type": "array",
                "items": { "type": "string" }
            }
        }
    }"#;

    let expected: &str = r"//! Generated by json-schema-rs. Do not edit manually.

use serde::{Deserialize, Serialize};

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct WithArrays {
    pub labels: Option<Vec<String>>,
    pub tags: Vec<String>,
}

";

    let mut output: Vec<u8> = Vec::new();
    generate_to_writer(schema_json, &mut output, &GenerateSettings::default())
        .expect("generate_to_writer should succeed");

    let actual: String = String::from_utf8(output).expect("output should be valid UTF-8");

    assert_eq!(expected, actual, "expected output to match exactly");
}

#[test]
fn array_of_objects_nested_struct_emission_order() {
    let schema_json: &str = r#"{
        "type": "object",
        "title": "DocWithItems",
        "required": ["items"],
        "properties": {
            "items": {
                "type": "array",
                "items": {
                    "type": "object",
                    "title": "Item",
                    "required": ["id"],
                    "properties": {
                        "id": { "type": "string" },
                        "name": { "type": "string" }
                    }
                }
            }
        }
    }"#;

    let expected: &str = r"//! Generated by json-schema-rs. Do not edit manually.

use serde::{Deserialize, Serialize};

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct Item {
    pub id: String,
    pub name: Option<String>,
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct DocWithItems {
    pub items: Vec<Item>,
}

";

    let mut output: Vec<u8> = Vec::new();
    generate_to_writer(schema_json, &mut output, &GenerateSettings::default())
        .expect("generate_to_writer should succeed");

    let actual: String = String::from_utf8(output).expect("output should be valid UTF-8");

    assert_eq!(expected, actual, "expected output to match exactly");
}

#[test]
fn array_of_enums() {
    let schema_json: &str = r#"{
        "type": "object",
        "title": "DocWithStatuses",
        "properties": {
            "statuses": {
                "type": "array",
                "items": {
                    "type": "string",
                    "enum": ["active", "inactive"]
                }
            }
        }
    }"#;

    let expected: &str = r#"//! Generated by json-schema-rs. Do not edit manually.

use serde::{Deserialize, Serialize};

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub enum Statuses {
    #[serde(rename = "active")]
    Active,
    #[serde(rename = "inactive")]
    Inactive,
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct DocWithStatuses {
    pub statuses: Option<Vec<Statuses>>,
}

"#;

    let mut output: Vec<u8> = Vec::new();
    generate_to_writer(schema_json, &mut output, &GenerateSettings::default())
        .expect("generate_to_writer should succeed");

    let actual: String = String::from_utf8(output).expect("output should be valid UTF-8");

    assert_eq!(expected, actual, "expected output to match exactly");
}

#[test]
fn additional_properties_false_denies_unknown_fields() {
    let schema_json: &str = r#"{
        "type": "object",
        "title": "Strict",
        "additionalProperties": false,
        "properties": {
            "name": { "type": "string" }
        }
    }"#;

    let expected: &str = r"//! Generated by json-schema-rs. Do not edit manually.

use serde::{Deserialize, Serialize};

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
#[serde(deny_unknown_fields)]
pub struct Strict {
    pub name: Option<String>,
}

";

    let mut output: Vec<u8> = Vec::new();
    generate_to_writer(schema_json, &mut output, &GenerateSettings::default())
        .expect("generate_to_writer should succeed");

    let actual: String = String::from_utf8(output).expect("output should be valid UTF-8");

    assert_eq!(expected, actual, "expected output to match exactly");
}

#[test]
fn additional_properties_typed_string_generates_btreemap() {
    let schema_json: &str = r#"{
        "type": "object",
        "title": "WithExtras",
        "additionalProperties": { "type": "string" },
        "properties": {
            "id": { "type": "string" }
        }
    }"#;

    let expected: &str = r"//! Generated by json-schema-rs. Do not edit manually.

use serde::{Deserialize, Serialize};
use std::collections::BTreeMap;

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct WithExtras {
    #[serde(flatten)]
    pub additional_properties: BTreeMap<String, String>,
    pub id: Option<String>,
}

";

    let mut output: Vec<u8> = Vec::new();
    generate_to_writer(schema_json, &mut output, &GenerateSettings::default())
        .expect("generate_to_writer should succeed");

    let actual: String = String::from_utf8(output).expect("output should be valid UTF-8");

    assert_eq!(expected, actual, "expected output to match exactly");
}

#[test]
fn additional_properties_typed_integer_generates_btreemap() {
    let schema_json: &str = r#"{
        "type": "object",
        "title": "Counts",
        "additionalProperties": { "type": "integer" },
        "properties": {
            "total": { "type": "integer" }
        }
    }"#;

    let expected: &str = r"//! Generated by json-schema-rs. Do not edit manually.

use serde::{Deserialize, Serialize};
use std::collections::BTreeMap;

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct Counts {
    #[serde(flatten)]
    pub additional_properties: BTreeMap<String, i64>,
    pub total: Option<i64>,
}

";

    let mut output: Vec<u8> = Vec::new();
    generate_to_writer(schema_json, &mut output, &GenerateSettings::default())
        .expect("generate_to_writer should succeed");

    let actual: String = String::from_utf8(output).expect("output should be valid UTF-8");

    assert_eq!(expected, actual, "expected output to match exactly");
}

#[test]
fn additional_properties_untyped_generates_json_value() {
    let schema_json: &str = r#"{
        "type": "object",
        "title": "Flexible",
        "additionalProperties": {},
        "properties": {
            "tag": { "type": "string" }
        }
    }"#;

    let expected: &str = r"//! Generated by json-schema-rs. Do not edit manually.

use serde::{Deserialize, Serialize};
use std::collections::BTreeMap;

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct Flexible {
    #[serde(flatten)]
    pub additional_properties: BTreeMap<String, serde_json::Value>,
    pub tag: Option<String>,
}

";

    let mut output: Vec<u8> = Vec::new();
    generate_to_writer(schema_json, &mut output, &GenerateSettings::default())
        .expect("generate_to_writer should succeed");

    let actual: String = String::from_utf8(output).expect("output should be valid UTF-8");

    assert_eq!(expected, actual, "expected output to match exactly");
}

#[test]
fn default_serde_default_for_bool_false() {
    let schema_json: &str = r#"{
        "type": "object",
        "title": "Flags",
        "properties": {
            "enabled": { "type": "boolean", "default": false }
        }
    }"#;

    let expected: &str = r"//! Generated by json-schema-rs. Do not edit manually.

use serde::{Deserialize, Serialize};

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct Flags {
    #[serde(default)]
    pub enabled: Option<bool>,
}

";

    let mut output: Vec<u8> = Vec::new();
    generate_to_writer(schema_json, &mut output, &GenerateSettings::default())
        .expect("generate_to_writer should succeed");

    let actual: String = String::from_utf8(output).expect("output should be valid UTF-8");

    assert_eq!(expected, actual, "expected output to match exactly");
}

#[test]
fn default_serde_default_for_integer_zero() {
    let schema_json: &str = r#"{
        "type": "object",
        "title": "Counter",
        "properties": {
            "count": { "type": "integer", "default": 0 }
        }
    }"#;

    let expected: &str = r"//! Generated by json-schema-rs. Do not edit manually.

use serde::{Deserialize, Serialize};

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct Counter {
    #[serde(default)]
    pub count: Option<i64>,
}

";

    let mut output: Vec<u8> = Vec::new();
    generate_to_writer(schema_json, &mut output, &GenerateSettings::default())
        .expect("generate_to_writer should succeed");

    let actual: String = String::from_utf8(output).expect("output should be valid UTF-8");

    assert_eq!(expected, actual, "expected output to match exactly");
}

#[test]
fn default_literal_string() {
    let schema_json: &str = r#"{
        "type": "object",
        "title": "Greeting",
        "properties": {
            "message": { "type": "string", "default": "hello" }
        }
    }"#;

    let expected: &str = r#"//! Generated by json-schema-rs. Do not edit manually.

use serde::{Deserialize, Serialize};

fn default_Greeting_message() -> Option<String> {
    Some("hello".to_string())
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct Greeting {
    #[serde(default = "default_Greeting_message")]
    pub message: Option<String>,
}

"#;

    let mut output: Vec<u8> = Vec::new();
    generate_to_writer(schema_json, &mut output, &GenerateSettings::default())
        .expect("generate_to_writer should succeed");

    let actual: String = String::from_utf8(output).expect("output should be valid UTF-8");

    assert_eq!(expected, actual, "expected output to match exactly");
}

#[test]
fn default_literal_integer() {
    let schema_json: &str = r#"{
        "type": "object",
        "title": "Config",
        "properties": {
            "limit": { "type": "integer", "default": 42 }
        }
    }"#;

    let expected: &str = r#"//! Generated by json-schema-rs. Do not edit manually.

use serde::{Deserialize, Serialize};

fn default_Config_limit() -> Option<i64> {
    Some(42i64)
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct Config {
    #[serde(default = "default_Config_limit")]
    pub limit: Option<i64>,
}

"#;

    let mut output: Vec<u8> = Vec::new();
    generate_to_writer(schema_json, &mut output, &GenerateSettings::default())
        .expect("generate_to_writer should succeed");

    let actual: String = String::from_utf8(output).expect("output should be valid UTF-8");

    assert_eq!(expected, actual, "expected output to match exactly");
}

#[test]
fn default_enum_variant() {
    let schema_json: &str = r#"{
        "type": "object",
        "title": "Doc",
        "properties": {
            "status": {
                "type": "string",
                "enum": ["active", "inactive"],
                "default": "active"
            }
        }
    }"#;

    let expected: &str = r#"//! Generated by json-schema-rs. Do not edit manually.

use serde::{Deserialize, Serialize};

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub enum Status {
    #[serde(rename = "active")]
    Active,
    #[serde(rename = "inactive")]
    Inactive,
}

fn default_Doc_status() -> Option<Status> {
    Some(Status::Active)
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct Doc {
    #[serde(default = "default_Doc_status")]
    pub status: Option<Status>,
}

"#;

    let mut output: Vec<u8> = Vec::new();
    generate_to_writer(schema_json, &mut output, &GenerateSettings::default())
        .expect("generate_to_writer should succeed");

    let actual: String = String::from_utf8(output).expect("output should be valid UTF-8");

    assert_eq!(expected, actual, "expected output to match exactly");
}

#[test]
fn default_empty_array() {
    let schema_json: &str = r#"{
        "type": "object",
        "title": "WithTags",
        "properties": {
            "tags": {
                "type": "array",
                "items": { "type": "string" },
                "default": []
            }
        }
    }"#;

    let expected: &str = r"//! Generated by json-schema-rs. Do not edit manually.

use serde::{Deserialize, Serialize};

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct WithTags {
    #[serde(default)]
    pub tags: Option<Vec<String>>,
}

";

    let mut output: Vec<u8> = Vec::new();
    generate_to_writer(schema_json, &mut output, &GenerateSettings::default())
        .expect("generate_to_writer should succeed");

    let actual: String = String::from_utf8(output).expect("output should be valid UTF-8");

    assert_eq!(expected, actual, "expected output to match exactly");
}

#[test]
fn default_required_field() {
    let schema_json: &str = r#"{
        "type": "object",
        "title": "WithDefault",
        "required": ["name"],
        "properties": {
            "name": { "type": "string", "default": "unnamed" }
        }
    }"#;

    let expected: &str = r#"//! Generated by json-schema-rs. Do not edit manually.

use serde::{Deserialize, Serialize};

fn default_WithDefault_name() -> String {
    "unnamed".to_string()
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct WithDefault {
    #[serde(default = "default_WithDefault_name")]
    pub name: String,
}

"#;

    let mut output: Vec<u8> = Vec::new();
    generate_to_writer(schema_json, &mut output, &GenerateSettings::default())
        .expect("generate_to_writer should succeed");

    let actual: String = String::from_utf8(output).expect("output should be valid UTF-8");

    assert_eq!(expected, actual, "expected output to match exactly");
}

#[test]
fn default_optional_field_null_uses_serde_default() {
    let schema_json: &str = r#"{
        "type": "object",
        "title": "OptNull",
        "properties": {
            "extra": { "type": "string", "default": null }
        }
    }"#;

    let expected: &str = r"//! Generated by json-schema-rs. Do not edit manually.

use serde::{Deserialize, Serialize};

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct OptNull {
    #[serde(default)]
    pub extra: Option<String>,
}

";

    let mut output: Vec<u8> = Vec::new();
    generate_to_writer(schema_json, &mut output, &GenerateSettings::default())
        .expect("generate_to_writer should succeed");

    let actual: String = String::from_utf8(output).expect("output should be valid UTF-8");

    assert_eq!(expected, actual, "expected output to match exactly");
}

#[test]
fn additional_properties_nested_object() {
    let schema_json: &str = r#"{
        "type": "object",
        "title": "Doc",
        "additionalProperties": {
            "type": "object",
            "properties": {
                "value": { "type": "string" }
            }
        },
        "properties": {
            "id": { "type": "string" }
        }
    }"#;

    let expected: &str = r"//! Generated by json-schema-rs. Do not edit manually.

use serde::{Deserialize, Serialize};
use std::collections::BTreeMap;

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct DocExtra {
    pub value: Option<String>,
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct Doc {
    #[serde(flatten)]
    pub additional_properties: BTreeMap<String, DocExtra>,
    pub id: Option<String>,
}

";

    let mut output: Vec<u8> = Vec::new();
    generate_to_writer(schema_json, &mut output, &GenerateSettings::default())
        .expect("generate_to_writer should succeed");

    let actual: String = String::from_utf8(output).expect("output should be valid UTF-8");

    assert_eq!(expected, actual, "expected output to match exactly");
}

#[test]
fn string_with_format_uuid_generates_uuid_type() {
    let schema_json: &str = r#"{
        "type": "object",
        "title": "Record",
        "required": ["id"],
        "properties": {
            "id": { "type": "string", "format": "uuid" }
        }
    }"#;

    let expected: &str = r"//! Generated by json-schema-rs. Do not edit manually.

use serde::{Deserialize, Serialize};
use uuid::Uuid;

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct Record {
    pub id: Uuid,
}

";

    let mut output: Vec<u8> = Vec::new();
    generate_to_writer(schema_json, &mut output, &GenerateSettings::default())
        .expect("generate_to_writer should succeed");

    let actual: String = String::from_utf8(output).expect("output should be valid UTF-8");

    assert_eq!(expected, actual, "expected output to match exactly");
}

#[test]
fn string_with_format_uuid4_generates_uuid_type() {
    let schema_json: &str = r#"{
        "type": "object",
        "title": "Entity",
        "properties": {
            "id": { "type": "string", "format": "uuid4" }
        }
    }"#;

    let expected: &str = r"//! Generated by json-schema-rs. Do not edit manually.

use serde::{Deserialize, Serialize};
use uuid::Uuid;

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct Entity {
    pub id: Option<Uuid>,
}

";

    let mut output: Vec<u8> = Vec::new();
    generate_to_writer(schema_json, &mut output, &GenerateSettings::default())
        .expect("generate_to_writer should succeed");

    let actual: String = String::from_utf8(output).expect("output should be valid UTF-8");

    assert_eq!(expected, actual, "expected output to match exactly");
}

#[test]
fn string_without_format_remains_string() {
    let schema_json: &str = r#"{
        "type": "object",
        "title": "Item",
        "properties": {
            "name": { "type": "string" }
        }
    }"#;

    let expected: &str = r"//! Generated by json-schema-rs. Do not edit manually.

use serde::{Deserialize, Serialize};

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct Item {
    pub name: Option<String>,
}

";

    let mut output: Vec<u8> = Vec::new();
    generate_to_writer(schema_json, &mut output, &GenerateSettings::default())
        .expect("generate_to_writer should succeed");

    let actual: String = String::from_utf8(output).expect("output should be valid UTF-8");

    assert_eq!(expected, actual, "expected output to match exactly");
}

#[test]
fn array_of_uuid_items() {
    let schema_json: &str = r#"{
        "type": "object",
        "title": "Batch",
        "properties": {
            "ids": {
                "type": "array",
                "items": { "type": "string", "format": "uuid" }
            }
        }
    }"#;

    let expected: &str = r"//! Generated by json-schema-rs. Do not edit manually.

use serde::{Deserialize, Serialize};
use uuid::Uuid;

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct Batch {
    pub ids: Option<Vec<Uuid>>,
}

";

    let mut output: Vec<u8> = Vec::new();
    generate_to_writer(schema_json, &mut output, &GenerateSettings::default())
        .expect("generate_to_writer should succeed");

    let actual: String = String::from_utf8(output).expect("output should be valid UTF-8");

    assert_eq!(expected, actual, "expected output to match exactly");
}

#[test]
fn uuid_with_default() {
    let schema_json: &str = r#"{
        "type": "object",
        "title": "Record",
        "properties": {
            "id": {
                "type": "string",
                "format": "uuid",
                "default": "550e8400-e29b-41d4-a716-446655440000"
            }
        }
    }"#;

    let expected: &str = r#"//! Generated by json-schema-rs. Do not edit manually.

use serde::{Deserialize, Serialize};
use uuid::Uuid;

fn default_Record_id() -> Option<Uuid> {
    Some(Uuid::parse_str("550e8400-e29b-41d4-a716-446655440000").expect("invalid default uuid"))
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct Record {
    #[serde(default = "default_Record_id")]
    pub id: Option<Uuid>,
}

"#;

    let mut output: Vec<u8> = Vec::new();
    generate_to_writer(schema_json, &mut output, &GenerateSettings::default())
        .expect("generate_to_writer should succeed");

    let actual: String = String::from_utf8(output).expect("output should be valid UTF-8");

    assert_eq!(expected, actual, "expected output to match exactly");
}

// --- Settings and deny_invalid_unknown_json_schema integration tests ---

/// Sorts issues for deterministic comparison. Validation iterates over JSON object
/// keys (`HashMap`) which is non-deterministic, so issue order can vary.
fn sorted_issues(err: &SchemaValidationError) -> Vec<SchemaValidationIssue> {
    let mut issues = err.issues.clone();
    issues.sort_by(|a, b| {
        a.path
            .cmp(&b.path)
            .then_with(|| format!("{:?}", a.kind).cmp(&format!("{:?}", b.kind)))
    });
    issues
}

#[test]
fn deny_mode_returns_schema_validation_error_for_unsupported_ref() {
    let schema_json: &str = r##"{
        "type": "object",
        "properties": { "foo": { "type": "string" } },
        "$ref": "#/definitions/Other"
    }"##;
    let settings = GenerateSettings {
        deny_invalid_unknown_json_schema: true,
    };

    let mut output: Vec<u8> = Vec::new();
    let result = generate_to_writer(schema_json, &mut output, &settings);

    let err = result.unwrap_err();
    let JsonSchemaGenError::SchemaValidation(actual) = err else {
        panic!("expected SchemaValidation error, got {err:?}");
    };

    let expected = SchemaValidationError {
        issues: vec![SchemaValidationIssue {
            path: "/$ref".to_string(),
            kind: SchemaValidationIssueKind::UnsupportedKeywordRef,
        }],
    };

    assert_eq!(
        sorted_issues(&expected),
        sorted_issues(&actual),
        "expected full SchemaValidationError to match"
    );
}

#[test]
fn deny_mode_collects_multiple_issues() {
    let schema_json: &str = r##"{
        "type": "object",
        "properties": {},
        "$ref": "#/Foo",
        "oneOf": [{ "type": "string" }]
    }"##;
    let settings = GenerateSettings {
        deny_invalid_unknown_json_schema: true,
    };

    let mut output: Vec<u8> = Vec::new();
    let result = generate_to_writer(schema_json, &mut output, &settings);

    let err = result.unwrap_err();
    let JsonSchemaGenError::SchemaValidation(actual) = err else {
        panic!("expected SchemaValidation error, got {err:?}");
    };

    let expected = SchemaValidationError {
        issues: vec![
            SchemaValidationIssue {
                path: String::new(),
                kind: SchemaValidationIssueKind::NoStructsToGenerate,
            },
            SchemaValidationIssue {
                path: "/$ref".to_string(),
                kind: SchemaValidationIssueKind::UnsupportedKeywordRef,
            },
            SchemaValidationIssue {
                path: "/oneOf".to_string(),
                kind: SchemaValidationIssueKind::UnsupportedKeywordOneOf,
            },
        ],
    };

    assert_eq!(
        sorted_issues(&expected),
        sorted_issues(&actual),
        "expected full SchemaValidationError to match"
    );
}

#[test]
fn default_settings_lenient_schema_with_unsupported_keyword_succeeds() {
    // With default (lenient) settings, $ref is ignored and generation succeeds.
    let schema_json: &str = r##"{
        "type": "object",
        "title": "Foo",
        "properties": {
            "name": { "type": "string" }
        },
        "$ref": "#/definitions/Extra"
    }"##;
    let settings = GenerateSettings::default();
    assert!(!settings.deny_invalid_unknown_json_schema);

    let mut output: Vec<u8> = Vec::new();
    let result = generate_to_writer(schema_json, &mut output, &settings);
    assert!(
        result.is_ok(),
        "with default settings, generation should succeed: {result:?}"
    );
}
